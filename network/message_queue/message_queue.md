# Message Queue

Message queuing allows applications to communicate by sending messages to each other. 
Message queue provides temporary message storage when the destination program is busy or not connected.

### Broker vs No Broker

* Broker

Architecture of most messaging systems is distinctive by the messaging server ("broker") acted as a central message delivery hub (such as ROS' master node).

Publishers and listeners do not know the addresses of each other, only deliver messages to the hub.

Drawback is that, hub can be a single point failure, and messages routing to hub then to listeners incurs excessive network burden.

<div style="display: flex; justify-content: center;">
      <img src="imgs/broker_mq.png" width="30%" height="30%" alt="broker_mq" />
</div>
</br>

* No Broker

Each app only knows limited number of addresses of other apps.
Without a prior known route table, it needs to traverse various apps to find the address of its message's destination address.

<div style="display: flex; justify-content: center;">
      <img src="imgs/raw_no_broker.png" width="30%" height="30%" alt="raw_no_broker" />
</div>
</br>

Distributed Directory Service (DDS) is the solution where directory service maintains route tables.
The directory service servers can copy from each other.
There should be more than one directory service servers to avoid single point failure.

In the example below, `Qi` is the message queue channel.
Directory service tells `App A` how to reach `App D` (assumed no direct message queue channel established in between).
<div style="display: flex; justify-content: center;">
      <img src="imgs/dds_no_broker.png" width="30%" height="30%" alt="dds_no_broker" />
</div>
</br>

### Formatting and Serialization (`printf` vs `std::cout`)

Serialization is a method converting objects into binary format.

`std::cout` is an object of class `ostream` that represents the standard output stream oriented to narrow characters (of type char). 
It corresponds to the C stream stdout.
It needs overloading `operator <<` abuse of `iostream`, this adds complexity but provides good extensibility.

`printf` is fast (fewer lines of compiled assembly code) and portable friendly.

## Message Queue and Multi-Threading

### From Linux TCP to Socket

Once a TCP packet finishes processing by Linux, it would be stored in one of the queue below
1. packets in flight
2. backlog
3. prequeue
4. receive_queue

Then, when `recv(int sockfd, void *buf, size_t len, int flags);` gets called, 
TCP packet's data is copied from kernel TCP queues' buffer to the user defined buffer `buf` by user specified number  of bytes `len`.

### Lock-Free Message Queue 

Lock-free message queue usually refers to using *Compare And Swap* (CAS) `compare_exchange_weak(...)` to guarantee thread safety avoid lock-introduced, kernel space/user space switch, and thread-switch related costs.

`compare_exchange_weak` compares `*this` with that of expected
```cpp
// since c++11
bool compare_exchange_weak( T& expected, T desired,
                            std::memory_order order =
                                std::memory_order_seq_cst ) noexcept;
```

* Lock-Free Message Queue (Array)



* Lock-Free Message Queue (List)

## Protobuf

Protocol Buffers serialize structured data into binary so it can be efficiently stored or shared over a network. 

### Quick Start

Install by
```bash
sudo apt-get update
sudp apt-get install protobuf-compiler
```

Write down a message `${SRC_DIR}/stock.proto`
```proto
syntax = "proto3";

option stock_namespace = "TraderSys";

message Stock {

    int32 id = 1;
    string symbol = 2;
    string display_name = 3;
    int32 market_id = 4;

}
```

Compile by `protoc -I=${SRC_DIR} --cpp_out=${DST_DIR} ${SRC_DIR}/stock.proto`

### Encoding Details

A protocol buffer message is a series of key-value pairs. 
The binary version of a message just uses the field’s number as the key – the name and declared type for each field can only be determined on the decoding end by referencing the message type’s definition (i.e. the `.proto` file).

As a result, protobuf does not have embedded delimiters between fields, but byte offsets corresponding to the reference types by the field’s number.

### Protobuf Compatibility

* Consider removing builtin protobuf versions that come with many libs such as Anaconda and `grpc`, then set up a new `protoc` path.
Existing protobuf can be found via `whereis protoc`

* The field number `1`, `2`, ... are used to identify fields in the binary encoded data, which means they can't change from version to version of your service. The advantage is that backward compatibility and forward compatibility are possible. 

* Error about old version incompatibility, should install a new version.
```
This file was generated by an older version of protoc which is incompatible with your Protocol Buffer headers. Please  regenerate this file with a newer version of protoc.
```

* String only supports UTF-8 or ASCII encoding.

* Should use `package namespace` to avoid namespace conflicts

* `bool` value interpretation: in common c++ compiler, `bool` can be represented as 0x01 or 0xff that both represent `true`.
However, in protobuf, `true` can be only said to be 0x01, `false` be 0x00.
The 0xff is invalid in protobuf and raises error.

### Protobuf Safety

* Thread safety, put simply, read-only access to an object can happen in multiple threads simultaneously, but write access can only happen in a single thread at a time.

### Protobuf Encoding/Decoding (Serialization/Deserialization) Performance

* By `VARINT` encoding implementation, `int` types are faster in serialization/deserialization than that of `float`.

* `repeated` fields of scalar type (primitive numeric types such as `VARINT`, `IS3` (fixed32, sfixed32, float)) can be declared as “packed”.
By being packed, elements are bulk encoded/decoded rather than one by one processed.

Instead of being encoded as one record per entry, they are encoded as a single `LEN` record that contains each element concatenated. 
To decode, elements are decoded from the `LEN` record one by one until the payload is exhausted. 

In proto2 this is done with using the field option `[packed=true]`, but in proto3 it is the default. 

For example, user provides three values $3$, $270$, and $86942$ for the repeated field `f`, or represented in Protoscope text `6: {3 270 86942}`.
Having encoded, it renders `3206038e029ea705`.
```protobuf
message Test5 {
  repeated int32 f = 6 [packed=true];
}
```

If not, it might be represented in Protoscope text `6: {3}, 6: {270}, 6: {86942}`, added unnecessary type reference work.

* For large messages, decompose it into many small messages

The main problem with protobuf for large files is that it doesn't support random access. 
User has to read the whole file, even if you only want to access a specific item. 

For example, OpenStreetMap does not have the entire file as a single message. Instead it consists of thousands individual messages, each encoding a part of the map. 